from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem, 
    QHeaderView, QListWidget, QSplitter, QMenu, QMessageBox
)

from PyQt5.QtCore import pyqtSignal, Qt, QTimer

import pandas as pd
import os
import json


class VulnerabilityPage(QWidget):
    """漏洞展示页面"""
    status_changed = pyqtSignal(str)

    def __init__(self, parent=None):
        super().__init__(parent)
        # 获取DPI缩放比例
        self.dpi_scale = self.get_dpi_scale()
        
        from . import styles
        # 使用动态生成的样式，传入DPI缩放比例
        self.setStyleSheet(styles.get_style(self.dpi_scale))
        
        self.scan_results_dir = "results/afrog"
        self.init_ui()
        self.load_scan_files()
        
    def get_dpi_scale(self):
        """获取DPI缩放比例"""
        import platform
        from PyQt5.QtWidgets import QApplication
        
        if platform.system() == 'Windows':
            try:
                # 获取主屏幕
                screen = QApplication.primaryScreen()
                dpi = screen.logicalDotsPerInch()
                
                # 标准DPI是96
                scale = dpi / 96.0
                
                # 限制缩放范围，避免过大或过小
                scale = max(0.8, min(scale, 2.0))
                
                return scale
            except Exception as e:
                print(f"获取DPI缩放失败: {e}")
                return 1.0
        else:
            # 非Windows系统返回默认值
            return 1.0

    def init_ui(self):
        """初始化界面"""
        # 根据DPI缩放调整边距
        margin = int(10 * self.dpi_scale)
        self.main_layout = QHBoxLayout(self)
        self.main_layout.setContentsMargins(margin, margin, margin, margin)
        
        # 创建分割器
        self.splitter = QSplitter(Qt.Horizontal)
        
        # 扫描文件列表
        self.scan_list = QListWidget()
        # 根据DPI缩放调整宽度
        self.scan_list.setFixedWidth(int(200 * self.dpi_scale))
        self.scan_list.itemClicked.connect(self.on_scan_selected)
        self.scan_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.scan_list.customContextMenuRequested.connect(self.show_context_menu)
        
        # 漏洞结果表格
        self.result_table = QTableWidget()
        self.result_table.setColumnCount(6)
        self.result_table.setHorizontalHeaderLabels([
            "目标", "漏洞名称", "风险等级", "描述", "作者", "URL"
        ])
        self.result_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.result_table.horizontalHeader().setStretchLastSection(True)
        
        # 添加到分割器
        self.splitter.addWidget(self.scan_list)
        self.splitter.addWidget(self.result_table)
        
        self.main_layout.addWidget(self.splitter)
        self.setLayout(self.main_layout)


    def update_results(self, results):
        """更新漏洞结果"""
        self.result_table.setRowCount(0)
        
        if not results or not isinstance(results, list):
            self.status_changed.emit("无漏洞结果")
            return
            
        # 确保列数匹配
        if self.result_table.columnCount() != 6:
            self.result_table.setColumnCount(6)
            self.result_table.setHorizontalHeaderLabels([
                "目标", "漏洞名称", "风险等级", "描述", "作者", "URL"
            ])
            
        for row, item in enumerate(results):
            if not isinstance(item, dict):
                continue
                
            self.result_table.insertRow(row)
            
            # 安全地获取每个字段
            target = str(item.get("目标", item.get("target", "")))
            vuln_name = str(item.get("漏洞名称", item.get("pocinfo", {}).get("infoname", "")))
            risk_level = str(item.get("风险等级", item.get("pocinfo", {}).get("infoseg", "")))
            description = str(item.get("描述", item.get("pocinfo", {}).get("infodescription", "")))
            author = str(item.get("作者", item.get("pocinfo", {}).get("infoauthor", "")))
            url = str(item.get("URL", item.get("fulltarget", "")))
            
            # 创建表格项并设置
            self.result_table.setItem(row, 0, QTableWidgetItem(target))
            self.result_table.setItem(row, 1, QTableWidgetItem(vuln_name))
            self.result_table.setItem(row, 2, QTableWidgetItem(risk_level))
            self.result_table.setItem(row, 3, QTableWidgetItem(description))
            self.result_table.setItem(row, 4, QTableWidgetItem(author))
            self.result_table.setItem(row, 5, QTableWidgetItem(url))
            
            # 自动调整行高
            self.result_table.resizeRowToContents(row)
            
        # 自动调整列宽
        self.result_table.resizeColumnsToContents()
        self.status_changed.emit(f"共发现 {len(results)} 个漏洞")


    def load_scan_files(self):
        """加载扫描结果文件"""
        self.scan_list.clear()
        
        if not os.path.exists(self.scan_results_dir):
            os.makedirs(self.scan_results_dir, exist_ok=True)
            return
            
        for filename in sorted(os.listdir(self.scan_results_dir)):
            if filename.endswith('.json'):
                self.scan_list.addItem(filename)

    def show_context_menu(self, position):
        """显示右键菜单"""
        item = self.scan_list.itemAt(position)
        if not item:
            return
            
        menu = QMenu()
        delete_action = menu.addAction("删除扫描结果")
        delete_action.triggered.connect(lambda: self.delete_scan_file(item))
        menu.exec_(self.scan_list.viewport().mapToGlobal(position))
        
    def delete_scan_file(self, item):
        """删除扫描结果文件"""
        try:
            file_path = os.path.join(self.scan_results_dir, item.text())
            
            # 确认对话框
            reply = QMessageBox.question(
                self, '确认删除',
                f'确定要删除扫描结果文件 {item.text()} 吗?',
                QMessageBox.Yes | QMessageBox.No, QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                try:
                    if os.path.exists(file_path):
                        os.remove(file_path)
                        # 延迟100ms确保文件操作完成
                        QTimer.singleShot(100, self.load_scan_files)
                        self.status_changed.emit(f"已删除扫描结果: {item.text()}")
                    else:
                        self.status_changed.emit(f"文件不存在: {item.text()}")
                except PermissionError:
                    self.status_changed.emit(f"删除失败: 文件正在被使用")
                except Exception as e:
                    self.status_changed.emit(f"删除失败: {str(e)}")
                    import traceback
                    traceback.print_exc()
        except Exception as e:
            self.status_changed.emit(f"操作异常: {str(e)}")
            import traceback
            traceback.print_exc()


    def on_scan_selected(self, item):
        """处理扫描文件选择事件"""
        file_path = os.path.join(self.scan_results_dir, item.text())

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
                
            # 支持多种结果格式
            if isinstance(data, dict):
                results = data.get('results', [])
            elif isinstance(data, list):
                results = data
            else:
                self.status_changed.emit("无效的扫描结果格式")
                return
                
            if not results:
                self.status_changed.emit("扫描结果为空")
                return
                
            # 标准化结果格式
            formatted_results = []
            for item in results:
                if not isinstance(item, dict):
                    continue
                    
                formatted_item = {
                    "目标": item.get("target", ""),
                    "漏洞名称": item.get("pocinfo", {}).get("infoname", ""),
                    "风险等级": item.get("pocinfo", {}).get("infoseg", ""),
                    "描述": item.get("pocinfo", {}).get("infodescription", ""),
                    "作者": item.get("pocinfo", {}).get("infoauthor", ""),
                    "URL": item.get("fulltarget", "")
                }
                formatted_results.append(formatted_item)
                
            if not formatted_results:
                self.status_changed.emit("没有有效的漏洞结果")
                return
                
            # 调用update_results显示结果
            self.update_results(formatted_results)


            
        except json.JSONDecodeError:
            self.status_changed.emit("扫描结果文件格式错误")
        except Exception as e:
            self.status_changed.emit(f"加载扫描结果失败: {str(e)}")

